# 递归思维

## 1. 递归的思维方式

递归思维方式的精髓在于判断能否将目前**复杂的问题转换为较为简单的同类问题**。可以的话，就先转换为简单的同类问题来解决，然后再利用同样的方法来解决复杂的同类问题。

**注意：**

不要陷入程序递归的内部去思考递归算法，要从递归思维的本质(**复杂问题简单化**)出发去理解递归算法。千万不要去通过试图解析程序执行的每一个步骤来理解递归（解析程序的执行是指给函数一个真实值，然后自己一步步去推出结果，这样的思考方式是错误的！），那样只会让自己得到伪理解的结果。记住！递归并不是算法，是一种复杂问题简单化的思维方式，而这种思维方式在程序中的体现就递归算法！递归算法在实现上就是函数不断调用自身的过程！

## 2. 递归的定义

递归是数学中的一个重要概念，而递归算法则是针对程序设计而言的，两者在本质上是一样的。

$\frac{1}{2}$

**递归的定义(从数学的角度)**——用一个概念的本身直接定义自己。如阶乘 F(n) = n! 可以定义为：

<div align=center><img src="https://note.youdao.com/yws/public/resource/06876692f80b5463f069b007ffcb1086/xmlnote/3777EC84F08848D990B98113CEFDB31D/10023" /></div>

**递归算法的定义(从程序的角度)**——方法中调用自身的过程就称为递归算法。

递归必须满足以下两个条件：

（1）**边界条件**：至少有一条初始定义是非递归的，如汉诺塔的H(0)=0，阶乘的0!=1。

（2）**递归通式**：由已知函数值逐步计算出未知函数值，如汉诺塔的H(0)=0，可以推算出H(1)=H(0)+1+H(0)。

边界条件和递推通式是递归定义的两个基本要素，缺一不可，并且递归通式必须在有限次数内运算完成达到边界条件以保证能够正常结束递归，得到运算结果。

## 3. 递归的三大要素

#### （1）第一要素——明确你这个方法要干什么

对于递归，定义一个方法时，首先要清楚这个方法的功能是什么，而这完全由你自己来定义。也就是说，先不管方法里面的代码是什么，先弄明白这个方法是用来干什么就可以了。

例如，定义一个方法算阶乘：
```java
// 算 n 的阶乘(假设n不为0)
int f(int n){
    
}
```
该方法的功能是算 n 的阶乘，接下来看第二要素。

#### （2）第二要素——寻找递归结束条件

递归就是在方法内部调用这个方法本身，所以，我们必须要找出递归的结束条件，不然会一直调用自己，进入死循环。也就是说，我们需要找出当参数为多少时，递归结束，之后直接把结果返回（注意：这个时候我们必须能根据这个参数，直接知道方法的结果是什么）。

例如，n 的阶乘，当 n = 1 时，就能直接知道 f(1) = 1，所以 f(1) = 1 就可以作为上面方法的结束条件。把第二要素加进代码里面，如下：
```java
// 算 n 的阶乘(假设n不为0)
int f(int n){
    if(n == 1){
        return 1;
    }
}
```
当然，当 n = 2 时，我们也可以直接知道 f(2)  = 2，也就可以把 f(2)  = 2 作为递归的结束条件。所以说，只要你觉得参数是什么时，你能够直接知道方法的结果，就可以把这个参数作为结束的条件。下面这样定义也是可以的。
```java
// 算 n 的阶乘(假设n>=2)
int f(int n){
    if(n == 2){
        return 2;
    }
}
```
但是写成 n == 2 会漏掉 n = 1 的情况，为了更加严谨，可以写成：
```java
// 算 n 的阶乘(假设n不为0)
int f(int n){
    if(n <= 2){
        return n;
    }
}
```
**注意：**

在寻找结束条件时，要多代入和检查，保证严谨，避免出现死循环。

#### （3）第三要素——找出函数的等价关系式（递推公式）

第三要素就是，不断缩小参数的范围，但要保持原函数的结果不变。

例如阶乘，f(n) 这个范围比较大，可以让 f(n) = n * f(n-1)。这样，范围就由 n 变成了 n-1 。也就是说，要找到原函数的一个等价关系式，即数学中的**递推公式**。把这个等价关系式写进方法里，就得到了完整的算阶乘的方法。如下：
```java
// 算 n 的阶乘(假设n不为0)
int f(int n){
    if(n <= 2){
        return n;
    }
    // 把 f(n) 的等价操作写进去
    return f(n-1) * n;
}
```
## 4. 案例
#### 4.1 斐波那契数列
###### （1）函数功能
假设 f(n) 的功能是求斐波那契数列第 n 项的值，代码如下：
```java
int f(int n){
    
}
```
###### （2）递归结束条件
当 n = 1 或者 n = 2 时，f（1）= f（2）= 1。所以递归结束条件可以为 n <= 2 时，f（n）= 1。代码如下：
```java
int f(int n){
    if(n <= 2){
        return 1;
    }
}
```
###### （3）函数的等价关系式
斐波那契数列满足递推公式： f(n) = f(n-1) + f(n-2)。最终代码如下：
```java
int f(int n){
    // 1.先写递归结束条件
    if(n <= 2){
        return 1;
    }
    // 2.接着写等价关系式
    return f(n - 1) + f(n - 2);
}
```
#### 4.2 小青蛙跳台阶
一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法？
###### （1）函数功能
假设 f(n) 的功能是求青蛙跳上一个 n 级台阶总共有多少种跳法，代码如下：

```java
int f(int n){
    
}
```
###### （2）递归结束条件
当 n = 1 时，f(1) = 1。代码如下：
```java
int f(int n){
    if(n == 1){
        return 1;
    }
}
```
###### （3）函数的等价关系式
每次跳的时候，小青蛙可以跳一个台阶，也可以跳两个台阶，也就是说，每次跳的时候，小青蛙有两种跳法。第一种跳法：第一次跳了一个台阶，剩下的 n-1 个台阶的跳法有 f(n-1) 种。第二种跳法：第一次跳了两个台阶，剩下的 n-2 个台阶的跳法有 f(n-2) 种。所以，小青蛙的全部跳法就是这两种跳法之和，即 f(n) = f(n-1) + f(n-2)。代码如下：
```java
int f(int n){
    if(n == 1){
        return 1;
    }
    ruturn f(n-1) + f(n-2);
}
```
检查递归结束条件，当 n = 2 时，有 f(2) = f(1) + f(0)。我们知道，f(0) = 0，本应该递归结束，但上面的代码逻辑中，还会继续调用 f(0) = f(-1) + f(-2)，导致无限调用，进入死循环。

所以，当我们在第二步找到一个递归结束条件时，先把结束条件写进代码，然后进行第三步。在找出等价关系式之后，要根据等价关系式验证结束条件是否漏掉了一些条件，然后完善结束条件，使得代码更加严谨。完整代码如下：
```java
int f(int n){
    //f(0) = 0,f(1) = 1，f(2) = 2等价于 n<=2时，f(n) = n。
    if(n <= 2){
        return n;
    }
    ruturn f(n-1) + f(n-2);
}
```
